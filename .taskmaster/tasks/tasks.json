{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Project Structure and Core Infrastructure",
        "description": "Set up the foundational directory structure, dependency management, configuration, and logging systems as outlined in the PRD. This task establishes the skeleton of the application.",
        "details": "Create the main directory structure: `trading_bot/core`, `trading_bot/market_data`, `trading_bot/strategies`, etc. Initialize a `requirements.txt` file with `python-binance`, `aiohttp`, `websockets`, `pandas`, `numpy`, and `discord-webhook`. Implement `core/config_manager.py` to load settings (API keys, Discord URL) from a `.env` or `config.ini` file. Implement `core/logger.py` for application-wide logging.",
        "testStrategy": "Verify that the directory structure is created correctly. Write a unit test for `ConfigManager` to ensure it correctly loads parameters from a sample config file. Confirm that the logger can write messages to both console and a file.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "프로젝트 디렉토리 구조 생성",
            "description": "트레이딩 봇 애플리케이션의 기본 디렉토리 구조를 생성합니다",
            "dependencies": [],
            "details": "trading_bot/core, trading_bot/market_data, trading_bot/strategies, trading_bot/risk_management, trading_bot/notification 등의 주요 디렉토리를 생성하고 각 디렉토리에 __init__.py 파일을 추가하여 Python 패키지로 설정합니다",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "프로젝트 종속성 관리 설정",
            "description": "requirements.txt 파일을 생성하고 필요한 Python 패키지들을 정의합니다",
            "dependencies": [
              "1.1"
            ],
            "details": "python-binance, aiohttp, websockets, pandas, numpy, discord-webhook 등 필수 라이브러리들을 포함한 requirements.txt 파일을 생성하고 적절한 버전을 명시합니다",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "설정 관리자 구현",
            "description": "애플리케이션 설정을 관리하는 ConfigManager 클래스를 구현합니다",
            "dependencies": [
              "1.1"
            ],
            "details": "core/config_manager.py에 ConfigManager 클래스를 구현하여 .env 또는 config.ini 파일에서 API 키, Discord URL 등의 설정값을 로드하고 관리하는 기능을 제공합니다",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "로깅 시스템 구현",
            "description": "애플리케이션 전체에서 사용할 로깅 시스템을 구현합니다",
            "dependencies": [
              "1.1"
            ],
            "details": "core/logger.py에 애플리케이션 전체에서 사용할 로거를 구현하여 콘솔과 파일 모두에 로그를 출력할 수 있도록 설정하고, 로그 레벨 및 포맷을 관리합니다",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Event-Driven Core with Event Hub",
        "description": "Develop the central `EventHub` based on a publish-subscribe pattern. This component is critical for decoupling all other modules and enabling the asynchronous architecture.",
        "details": "In `core/event_hub.py`, create an `EventHub` class. It should have methods like `subscribe(event_type, handler)` and `publish(event_type, data)`. The implementation must be thread-safe and support asynchronous handlers (`async def`). Define initial event types as constants (e.g., `MARKET_DATA_RECEIVED`, `TRADING_SIGNAL_GENERATED`).",
        "testStrategy": "Write unit tests to verify that a subscriber receives an event published to a specific topic. Test with multiple subscribers for the same event. Ensure that publishing an event to a topic with no subscribers does not cause an error. Test asynchronous handler execution.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "EventHub 클래스 기본 구조 설계 및 생성",
            "description": "core/event_hub.py 파일에 EventHub 클래스의 기본 구조를 정의하고 초기화 메서드를 구현합니다.",
            "dependencies": [],
            "details": "EventHub 클래스를 생성하고 구독자 저장을 위한 내부 데이터 구조(딕셔너리)를 초기화합니다. 스레드 안전성을 위한 Lock 객체도 함께 초기화합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "구독(subscribe) 메서드 구현",
            "description": "이벤트 타입과 핸들러를 받아 구독자를 등록하는 subscribe 메서드를 구현합니다.",
            "dependencies": [
              "2.1"
            ],
            "details": "event_type을 키로 하고 핸들러 리스트를 값으로 하는 구독자 관리 시스템을 구현합니다. 스레드 안전성을 보장하기 위해 Lock을 사용합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "발행(publish) 메서드 구현",
            "description": "이벤트 타입과 데이터를 받아 등록된 모든 구독자에게 이벤트를 발행하는 publish 메서드를 구현합니다.",
            "dependencies": [
              "2.2"
            ],
            "details": "비동기 핸들러와 동기 핸들러를 모두 지원하도록 구현합니다. asyncio.create_task를 사용하여 비동기 핸들러를 실행하고, 일반 함수는 직접 호출합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "스레드 안전성 및 비동기 처리 강화",
            "description": "EventHub의 모든 메서드에 대해 스레드 안전성을 보장하고 비동기 핸들러 실행을 최적화합니다.",
            "dependencies": [
              "2.3"
            ],
            "details": "threading.RLock 사용으로 재진입 가능한 락 구현, 비동기 핸들러 실행 시 예외 처리 추가, 핸들러 실행 실패가 다른 핸들러에 영향을 주지 않도록 격리합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "이벤트 타입 상수 정의 및 테스트",
            "description": "시스템에서 사용할 이벤트 타입 상수들을 정의하고 EventHub의 동작을 검증하는 테스트를 작성합니다.",
            "dependencies": [
              "2.4"
            ],
            "details": "MARKET_DATA_RECEIVED, TRADING_SIGNAL_GENERATED 등의 이벤트 타입 상수를 정의합니다. 단일/다중 구독자, 비동기 핸들러, 구독자가 없는 경우의 발행 등을 테스트합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Develop Binance API Client and WebSocket Manager",
        "description": "Create a robust client for interacting with the Binance API for both RESTful requests (account info, order placement) and WebSocket connections (market data streams).",
        "details": "In `market_data/binance_client.py`, wrap the `python-binance` library to handle API authentication using keys from `ConfigManager`. In `market_data/websocket_manager.py`, implement a class to manage the WebSocket connection for real-time kline/ticker data for BTC/USDT. It should include automatic reconnection logic and publish raw data to the `EventHub`.",
        "testStrategy": "Use the Binance Testnet. For `BinanceClient`, test fetching account balance. For `WebSocketManager`, connect to the testnet stream, verify that data is received, and confirm that it correctly publishes events to the `EventHub`. Simulate a connection drop to test the reconnection logic.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "python-binance 라이브러리 래퍼 클래스 구현",
            "description": "BinanceClient 클래스를 구현하여 python-binance 라이브러리를 래핑하고 기본 API 연결 기능을 제공합니다.",
            "dependencies": [],
            "details": "market_data/binance_client.py 파일에 BinanceClient 클래스를 생성합니다. python-binance 라이브러리의 Client 클래스를 래핑하여 계정 정보 조회, 주문 실행 등의 기본 기능을 제공하는 인터페이스를 구현합니다. 에러 핸들링과 로깅 기능을 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "ConfigManager를 통한 API 인증 시스템 구현",
            "description": "ConfigManager에서 바이낸스 API 키를 안전하게 가져와 인증을 처리하는 시스템을 구현합니다.",
            "dependencies": [
              "3.1"
            ],
            "details": "BinanceClient 클래스에 ConfigManager와 연동하여 API 키와 시크릿을 안전하게 로드하고 바이낸스 클라이언트를 초기화하는 기능을 구현합니다. 테스트넷과 메인넷 환경을 구분하여 설정할 수 있도록 합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "WebSocket 연결 관리자 기본 클래스 구현",
            "description": "market_data/websocket_manager.py에 WebSocket 연결을 관리하는 기본 클래스를 구현합니다.",
            "dependencies": [],
            "details": "WebSocketManager 클래스를 생성하여 바이낸스 WebSocket 스트림에 연결하는 기본 기능을 구현합니다. BTC/USDT kline과 ticker 데이터를 구독할 수 있는 메서드를 포함하고, 연결 상태를 모니터링하는 기능을 추가합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "자동 재연결 로직 구현",
            "description": "WebSocket 연결이 끊어졌을 때 자동으로 재연결을 시도하는 로직을 구현합니다.",
            "dependencies": [
              "3.3"
            ],
            "details": "WebSocketManager에 연결 상태를 감지하고 연결이 끊어졌을 때 지수 백오프 알고리즘을 사용하여 자동으로 재연결을 시도하는 기능을 구현합니다. 최대 재시도 횟수와 재연결 간격을 설정할 수 있도록 합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "실시간 데이터 스트림 처리 및 파싱",
            "description": "WebSocket으로 수신되는 실시간 마켓 데이터를 파싱하고 처리하는 기능을 구현합니다.",
            "dependencies": [
              "3.4"
            ],
            "details": "WebSocketManager에서 수신되는 JSON 데이터를 파싱하여 kline과 ticker 정보를 추출하는 기능을 구현합니다. 데이터 유효성 검증과 예외 처리를 포함하여 안정적인 데이터 처리가 가능하도록 합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "EventHub 통합 및 데이터 발행",
            "description": "처리된 마켓 데이터를 EventHub를 통해 다른 모듈로 발행하는 기능을 구현합니다.",
            "dependencies": [
              "3.5"
            ],
            "details": "WebSocketManager에서 파싱된 마켓 데이터를 EventHub의 publish 메서드를 사용하여 MARKET_DATA_RECEIVED 이벤트로 발행하는 기능을 구현합니다. 이벤트 데이터 구조를 정의하고 다른 모듈들이 쉽게 사용할 수 있도록 표준화합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Create Market Data Processor",
        "description": "Build a component that subscribes to raw market data from the WebSocket, processes it into a structured format, and publishes it for consumption by strategy modules.",
        "details": "Create `market_data/data_processor.py`. This class will subscribe to raw data events from the `WebSocketManager` via the `EventHub`. It will parse the raw data, potentially aggregate it into candles (e.g., 1-minute, 5-minute), and then publish a structured `MarketData` object (as defined in the PRD) back to the `EventHub` under a new topic like `CANDLE_DATA_PROCESSED`.",
        "testStrategy": "Write unit tests that feed sample raw WebSocket payloads to the processor and verify that the correct `MarketData` objects are generated. Test the subscription and publishing logic by mocking the `EventHub`.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "원시 데이터 파싱 로직 구현",
            "description": "WebSocket으로부터 받은 원시 시장 데이터를 파싱하고 검증하는 기본 로직을 구현합니다.",
            "dependencies": [],
            "details": "market_data/data_processor.py에서 원시 WebSocket 데이터 (kline/ticker)를 받아 파싱하는 메서드를 구현합니다. 데이터 형식 검증, 필수 필드 확인, 타임스탬프 정규화 등의 기본 처리 로직을 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "캔들 집계 알고리즘 개발",
            "description": "1분, 5분 등 다양한 시간 간격의 캔들 데이터를 집계하는 알고리즘을 구현합니다.",
            "dependencies": [
              "4.1"
            ],
            "details": "파싱된 원시 데이터를 기반으로 OHLCV (Open, High, Low, Close, Volume) 캔들을 생성하는 집계 로직을 구현합니다. 다중 시간 프레임 지원과 캔들 완성 이벤트 처리를 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "MarketData 객체 생성 및 구조화",
            "description": "PRD에 정의된 MarketData 객체 형식에 맞춰 처리된 데이터를 구조화합니다.",
            "dependencies": [
              "4.2"
            ],
            "details": "집계된 캔들 데이터를 MarketData 객체로 변환하는 로직을 구현합니다. 데이터 타입 변환, 필드 매핑, 객체 직렬화 등을 포함하여 일관된 데이터 구조를 보장합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "EventHub 연동 및 데이터 발행",
            "description": "EventHub를 통한 데이터 구독/발행 메커니즘을 구현하고 데이터 검증을 추가합니다.",
            "dependencies": [
              "4.3"
            ],
            "details": "EventHub에서 원시 데이터 이벤트를 구독하고, 처리된 MarketData 객체를 CANDLE_DATA_PROCESSED 토픽으로 발행하는 로직을 구현합니다. 에러 핸들링과 데이터 무결성 검증 로직을 포함합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Define Strategy Interface and Implement Basic ICT Strategy",
        "description": "Establish the standard interface for all trading strategies and implement the first MVP strategy based on the ICT Order Block concept.",
        "details": "In `strategies/base_strategy.py`, define an abstract base class `Strategy` with an abstract method `generate_signal(data: MarketData)`. In `strategies/ict_strategy.py`, create `ICTStrategy` inheriting from `Strategy`. Implement a simplified version of Order Block detection. When a signal is identified, it should create a `TradingSignal` dataclass instance and publish it to the `EventHub`.",
        "testStrategy": "Create a unit test for `ICTStrategy` with a predefined `pandas` DataFrame of candle data. The test should verify that a `TradingSignal` is correctly generated when an Order Block pattern appears in the data, and that no signal is generated otherwise.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "추상 Strategy 인터페이스 설계 및 구현",
            "description": "모든 트레이딩 전략의 기본이 되는 추상 Strategy 클래스를 정의하고 필수 메서드들을 설계합니다.",
            "dependencies": [],
            "details": "`strategies/base_strategy.py`에 추상 기본 클래스 `Strategy`를 생성합니다. `generate_signal(data: MarketData)` 추상 메서드와 전략 초기화, 설정 관리를 위한 기본 메서드들을 포함합니다. ABC(Abstract Base Class)를 사용하여 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "ICT Order Block 패턴 감지 알고리즘 구현",
            "description": "ICT 이론에 기반한 Order Block 패턴을 식별하는 핵심 알고리즘을 구현합니다.",
            "dependencies": [
              "5.1"
            ],
            "details": "ICT Order Block의 정의에 따라 가격 움직임에서 주요 지지/저항 영역을 감지하는 알고리즘을 구현합니다. 캔들스틱 데이터에서 브레이크아웃, 리테스트, 반전 패턴을 식별하는 로직을 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "ICTStrategy 클래스 구현 및 패턴 인식 로직",
            "description": "Strategy 인터페이스를 상속받는 ICTStrategy 클래스를 구현하고 Order Block 패턴 인식 로직을 통합합니다.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "`strategies/ict_strategy.py`에 `ICTStrategy` 클래스를 생성합니다. `generate_signal` 메서드에서 Order Block 감지 알고리즘을 활용하여 매매 신호를 생성하는 로직을 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "TradingSignal 데이터클래스 생성 및 신호 처리",
            "description": "거래 신호를 표현하는 TradingSignal 데이터클래스를 정의하고 신호 생성 로직을 구현합니다.",
            "dependencies": [
              "5.3"
            ],
            "details": "TradingSignal 데이터클래스에 진입가격, 방향(매수/매도), 신뢰도, 타임스탬프 등의 필드를 포함합니다. ICTStrategy에서 패턴이 감지되었을 때 적절한 TradingSignal 인스턴스를 생성하는 로직을 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "EventHub 신호 발행 및 통합",
            "description": "생성된 거래 신호를 EventHub를 통해 발행하는 기능을 구현합니다.",
            "dependencies": [
              "5.4"
            ],
            "details": "ICTStrategy에서 TradingSignal이 생성되었을 때 EventHub의 publish 메서드를 사용하여 `TRADING_SIGNAL_GENERATED` 이벤트를 발행합니다. 이벤트 타입 상수를 정의하고 적절한 에러 처리를 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "ICTStrategy 단위 테스트 및 백테스팅 검증",
            "description": "ICTStrategy의 정확성을 검증하기 위한 포괄적인 단위 테스트를 작성합니다.",
            "dependencies": [
              "5.5"
            ],
            "details": "미리 정의된 pandas DataFrame 캔들 데이터로 ICTStrategy를 테스트합니다. Order Block 패턴이 나타날 때 올바른 TradingSignal이 생성되는지, 패턴이 없을 때는 신호가 생성되지 않는지 검증합니다. 다양한 시장 상황에 대한 테스트 케이스를 포함합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Basic Risk Management Module",
        "description": "Develop the initial risk management component responsible for calculating position size and defining stop-loss/take-profit levels for a given trading signal.",
        "details": "Create `risk_management/position_sizer.py`. This module will subscribe to `TRADING_SIGNAL_GENERATED` events. Upon receiving a signal, it will calculate the appropriate position size based on a fixed risk percentage (e.g., 1% of total balance) defined in the configuration. It will then enrich the signal with position size, stop-loss, and take-profit prices, and publish a new `ORDER_REQUEST_GENERATED` event.",
        "testStrategy": "Write unit tests to verify correct position size calculation based on different account balances and risk percentages. Test that stop-loss and take-profit levels are calculated correctly based on the entry price and configured percentages/ATR.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "포지션 사이징 계산 알고리즘 구현",
            "description": "고정 리스크 비율 기반 포지션 크기 계산 로직 개발",
            "dependencies": [],
            "details": "계좌 잔고와 설정된 리스크 비율(예: 1%)을 기반으로 포지션 크기를 계산하는 알고리즘을 구현합니다. 다양한 계좌 크기와 리스크 설정에 대응할 수 있는 유연한 계산 로직을 포함해야 합니다.\n<info added on 2025-09-23T12:27:38.445Z>\n`position_sizer.py`에 구현된 강력한 포지션 사이징 계산 로직을 기반으로, 이를 전체 시스템에 통합하는 `RiskManager` 클래스를 구현합니다. 이 클래스는 트레이딩 시그널을 받아 리스크를 적용하고, 실행 가능한 주문 요청을 생성하는 오케스트레이터 역할을 합니다.\n\n**구현 사항:**\n\n1.  **`RiskManager` 클래스 생성:**\n    *   새로운 파일 `trading_bot/risk_management/risk_manager.py`를 생성합니다.\n    *   `RiskManager` 클래스를 정의합니다. 이 클래스는 초기화 시 `ConfigManager`로부터 리스크 관련 설정을 주입받고, 이를 사용하여 `position_sizer.py`의 `create_position_sizer()` 팩토리 함수를 호출해 `PositionSizer` 인스턴스를 생성 및 보유합니다.\n\n2.  **이벤트 핸들러 구현:**\n    *   `EventHub`를 구독하여 `TRADING_SIGNAL_GENERATED` 이벤트를 처리하는 비동기 핸들러 메서드(예: `async def on_trading_signal(self, signal_data)`)를 구현합니다.\n    *   핸들러 내에서, 수신된 시그널 데이터와 `PositionSizer` 인스턴스를 사용해 `calculate_position_size()`를 호출합니다.\n\n3.  **리스크 파라미터 계산 및 보강:**\n    *   포지션 크기 외에도, 설정된 전략(예: 고정 비율, ATR 기반)에 따라 손절(Stop-Loss) 및 익절(Take-Profit) 가격을 계산하는 로직을 추가합니다.\n    *   계산된 포지션 크기, 진입 가격, 손절 가격, 익절 가격 등의 모든 리스크 파라미터를 원본 시그널 데이터에 보강합니다.\n\n4.  **주문 요청 이벤트 발행:**\n    *   리스크 파라미터가 모두 적용된 최종 데이터를 사용하여 `ORDER_REQUEST_GENERATED` 이벤트를 `EventHub`에 발행합니다. 이 이벤트는 `ExecutionEngine` 모듈에서 구독하여 실제 주문을 실행하는 데 사용됩니다.\n\n**참조 파일 및 패턴:**\n*   **사용할 모듈:** `trading_bot/risk_management/position_sizer.py`의 `PositionSizer` 및 `create_position_sizer`\n*   **구독할 이벤트:** `TRADING_SIGNAL_GENERATED` (from `strategies/ict_strategy.py`)\n*   **발행할 이벤트:** `ORDER_REQUEST_GENERATED`\n*   **설정 관리:** `ConfigManager`를 통해 리스크 설정(예: `risk_percentage`, `sizing_method`)을 가져옵니다.\n*   **로깅:** 프로젝트의 표준 로거를 사용하여 주요 결정 과정을 기록합니다.\n</info added on 2025-09-23T12:27:38.445Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "위험도 기반 계산 로직 구현",
            "description": "트레이딩 신호의 위험도를 평가하고 리스크 관리 매개변수를 계산하는 로직 개발",
            "dependencies": [
              "6.1"
            ],
            "details": "입력된 트레이딩 신호를 분석하여 위험도를 평가하고, 이를 바탕으로 적절한 리스크 관리 매개변수를 계산합니다. 시장 변동성과 신호 강도를 고려한 동적 리스크 조정 기능을 포함합니다.\n<info added on 2025-09-23T16:10:45.859Z>\n### Implementation Summary\n\n**1. Core Logic Implementation:**\n- A comprehensive risk assessment system was implemented in `trading_bot/risk_management/risk_assessor.py`.\n- The main class, `RiskAssessor`, adheres to the `IRiskAssessor` interface, following SOLID principles. A factory function, `create_risk_assessor`, was also added for easy instantiation in `trading_bot/risk_management/__init__.py`.\n\n**2. Risk Assessment Process:**\n- The `assess` method takes a `TradingSignal` and other contextual data (e.g., portfolio state) to produce a `RiskAssessmentResult` dataclass.\n- This result object contains key outputs:\n    - `risk_multiplier`: A dynamic multiplier (e.g., 0.1x to 3.0x) used to adjust position sizes calculated by the `PositionSizer` (from subtask 6.1).\n    - `stop_loss_adjustment_factor`: A factor to dynamically widen or tighten stop-loss levels.\n    - `risk_level`: A qualitative assessment (e.g., 'Very Low', 'Moderate', 'High').\n    - `confidence_score`: A score indicating the reliability of the assessment itself.\n\n**3. Evaluated Risk Factors:**\n- The system analyzes multiple dimensions to determine the overall risk, including:\n    - Signal Quality (confidence, strength)\n    - Market Volatility (from market data)\n    - Position Concentration (requires portfolio context)\n    - Time Context (signal freshness)\n    - Strategy Track Record (historical performance)\n    - Market Correlation\n\n**4. Integration and Testing:**\n- The `RiskAssessor` integrates with the application's core by publishing its `RiskAssessmentResult` to the `EventHub`, making the analysis available to other modules like the upcoming `RiskManager`.\n- A comprehensive test suite with 65 tests was created in `tests/test_risk_assessor.py` to ensure correctness and reliability, covering various signal and market conditions.\n</info added on 2025-09-23T16:10:45.859Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "손절/익절 레벨 설정 기능 구현",
            "description": "진입가격 기반 손절매와 익절매 레벨을 자동 계산하는 기능 개발",
            "dependencies": [
              "6.2"
            ],
            "details": "진입가격을 기준으로 설정된 손절/익절 비율 또는 ATR 기반으로 스톱로스와 테이크프로핏 레벨을 자동 계산합니다. 다양한 계산 방식을 지원하고 설정 가능한 매개변수를 제공합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "계좌 잔고 기반 리스크 평가 시스템 구현",
            "description": "현재 계좌 상태를 고려한 포지션 리스크 평가 및 검증 로직 개발",
            "dependencies": [
              "6.3"
            ],
            "details": "현재 계좌 잔고, 기존 포지션, 미실현 손익을 종합하여 새로운 포지션의 리스크를 평가합니다. 과도한 레버리지나 집중 투자를 방지하는 안전장치를 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "ORDER_REQUEST 이벤트 생성 및 발행 기능 구현",
            "description": "계산된 리스크 매개변수를 포함한 주문 요청 이벤트 생성 및 EventHub 발행 기능 개발",
            "dependencies": [
              "6.4"
            ],
            "details": "TRADING_SIGNAL_GENERATED 이벤트를 구독하고, 리스크 관리 계산을 완료한 후 포지션 크기, 손절/익절 레벨이 포함된 ORDER_REQUEST_GENERATED 이벤트를 생성하여 EventHub에 발행합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Develop Order Execution Engine",
        "description": "Create the engine that translates trade signals into actual orders on the exchange. This component is responsible for placing, monitoring, and confirming trades.",
        "details": "In `trading/execution_engine.py`, create a class that subscribes to `ORDER_REQUEST_GENERATED` events from the risk manager. It will use the `BinanceClient` to place the market or limit order on the exchange. It should also handle order status updates (e.g., FILLED, CANCELED) and publish corresponding events like `ORDER_FILLED` to the `EventHub`.",
        "testStrategy": "Using the Binance Testnet, create an integration test. Manually publish an `ORDER_REQUEST_GENERATED` event and verify that the `ExecutionEngine` places the correct order on the testnet exchange. Check that an `ORDER_FILLED` event is published upon successful execution.",
        "priority": "high",
        "dependencies": [
          3,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "주문 요청 처리 로직 구현",
            "description": "ORDER_REQUEST_GENERATED 이벤트를 구독하고 주문 요청을 받아 처리하는 기본 구조를 구현합니다.",
            "dependencies": [],
            "details": "ExecutionEngine 클래스를 생성하고 EventHub에서 ORDER_REQUEST_GENERATED 이벤트를 구독하는 로직을 구현합니다. 이벤트 핸들러를 통해 주문 요청 데이터를 파싱하고 검증하는 기능을 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "바이낸스 주문 전송 기능 구현",
            "description": "BinanceClient를 사용하여 실제 거래소에 마켓/리미트 주문을 전송하는 기능을 구현합니다.",
            "dependencies": [
              "7.1"
            ],
            "details": "주문 요청 데이터를 바이낸스 API 형식으로 변환하고, BinanceClient를 통해 시장가/지정가 주문을 전송하는 로직을 구현합니다. 주문 전송 시 필요한 매개변수 설정과 API 호출을 처리합니다.\n<info added on 2025-09-23T21:52:06.595Z>\n```markdown\n**구현 완료 상세 내역:**\n\n*   **`ExecutionEngine` 클래스 업데이트:**\n    *   생성자를 통해 `BinanceClient`를 의존성으로 주입받도록 구조를 변경했습니다.\n    *   `_convert_to_binance_format` 및 `_convert_signal_to_side` 헬퍼 메서드를 구현하여, 내부 `OrderRequest` 데이터를 바이낸스 API가 요구하는 형식(사이드, 심볼, 수량 등)으로 변환하는 로직을 추가했습니다.\n\n*   **실제 주문 실행 로직 구현:**\n    *   기존의 시뮬레이션 로직을 `BinanceClient`의 실제 API 호출로 대체했습니다.\n    *   `_execute_binance_order` 메서드를 추가하여 주문 유형(시장가/지정가)에 따라 `binance_client.place_market_order()` 또는 `place_limit_order()`를 호출하도록 라우팅합니다.\n    *   `process_order_request` 메서드는 이 실행 흐름을 총괄합니다.\n\n*   **응답 처리 및 상태 관리:**\n    *   `_process_order_response` 메서드를 개선하여 실제 바이낸스 API 응답을 파싱하고, `orderId`를 추출하여 다음 단계(주문 상태 모니터링)에서 사용할 수 있도록 준비합니다.\n    *   바이낸스의 주문 상태(`FILLED`, `NEW`, `PARTIALLY_FILLED`)를 내부 `OrderStatus` 열거형(`EXECUTED`, `EXECUTING`)으로 매핑하는 로직을 구현했습니다.\n\n*   **에러 핸들링 및 재시도 메커니즘:**\n    *   `BinanceOrderError`, `BinanceRateLimitError`, `BinanceError` 등 바이낸스 API 호출 시 발생할 수 있는 특정 예외에 대한 처리 로직을 구현했습니다.\n    *   특히 `BinanceRateLimitError` 발생 시, `_handle_retry_delay` 메서드를 통해 최대 30초까지 지연되는 지수 백오프(exponential backoff) 재시도 로직을 적용하여 안정성을 높였습니다. 주문 자체의 오류(`BinanceOrderError`)는 재시도하지 않습니다.\n\n*   **통합 테스트:**\n    *   `tests/integration/test_execution_engine_integration.py`에 시장가/지정가 주문 성공, 주문 실패, API 속도 제한 및 재시도 로직 등 다양한 시나리오를 검증하는 통합 테스트 스위트를 작성하고 모든 테스트 통과를 확인했습니다.\n```\n</info added on 2025-09-23T21:52:06.595Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "주문 상태 모니터링 시스템 구현",
            "description": "전송된 주문의 상태를 실시간으로 모니터링하고 추적하는 시스템을 구현합니다.",
            "dependencies": [
              "7.2"
            ],
            "details": "주문 ID를 기반으로 주문 상태를 주기적으로 확인하고, FILLED, CANCELED, PARTIALLY_FILLED 등의 상태 변화를 감지하는 모니터링 로직을 구현합니다. 비동기 작업으로 처리하여 성능을 최적화합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "주문 체결 확인 및 처리 로직 구현",
            "description": "주문이 체결되었을 때의 확인 및 후속 처리 로직을 구현합니다.",
            "dependencies": [
              "7.3"
            ],
            "details": "주문 체결을 확인하고 체결가격, 체결수량, 수수료 등의 정보를 수집하여 처리하는 로직을 구현합니다. 부분 체결과 전체 체결을 구분하여 처리하는 기능을 포함합니다.\n<info added on 2025-09-23T22:02:46.195Z>\nThis will involve enhancing the `ExecutionEngine` in `trading/execution_engine.py`.\n\n**Implementation Plan:**\n\n1.  **Define `ExecutionResult` Data Structure:** Create a new `dataclass` named `ExecutionResult`, likely within `trading/execution_engine.py` or a shared types module. This structure should encapsulate all details of a filled order, including:\n    *   `order_id`: The exchange's order ID.\n    *   `client_order_id`: Our internal order ID.\n    *   `symbol`: The trading pair (e.g., 'BTCUSDT').\n    *   `side`: 'BUY' or 'SELL'.\n    *   `order_type`: 'LIMIT', 'MARKET', etc.\n    *   `cumulative_filled_quantity`: Total quantity filled.\n    *   `avg_fill_price`: The volume-weighted average price of all fills.\n    *   `commission_amount`: The total commission paid.\n    *   `commission_asset`: The asset in which commission was paid.\n    *   `slippage`: A newly calculated metric for execution quality.\n\n2.  **Enhance Fill Processing Logic:** In the `ExecutionEngine`, refine the method that handles order status updates from the `BinanceClient`. This logic must iterate through the `fills` array provided by the Binance API for a filled order. It will be responsible for:\n    *   Aggregating quantities and calculating the volume-weighted average price for partial fills.\n    *   Summing up commission costs from each partial fill.\n\n3.  **Calculate Execution Quality Metrics:**\n    *   Implement slippage calculation. For market orders, this will be the difference between the market price when the `ORDER_REQUEST_GENERATED` event was received and the final `avg_fill_price`. For limit orders, it's the difference between the limit price and `avg_fill_price`. This value will populate the `slippage` field in the `ExecutionResult`.\n\n4.  **Publish `ORDER_FILLED` Event:** After processing the fill data and constructing the complete `ExecutionResult` object, the `ExecutionEngine` will publish this object as the data payload for the `ORDER_FILLED` event via the `EventHub`.\n</info added on 2025-09-23T22:02:46.195Z>\n<info added on 2025-09-23T22:07:07.115Z>\n<info added on 2025-09-24T09:15:32.841Z>\n**Completion Summary & Enhancements:**\n\nThe fill confirmation and processing logic within `trading/execution_engine.py` has been successfully implemented, significantly exceeding the original plan's scope.\n\n1.  **Advanced Data Structures:**\n    *   The `ExecutionResult` dataclass was greatly expanded.\n    *   A new nested `FillDetail` dataclass was introduced to track each partial fill individually, capturing `price`, `quantity`, `commission_amount`, and `commission_asset` for each leg of the trade.\n    *   `ExecutionResult` now includes comprehensive statistics like `number_of_fills`, `time_to_fill_ms`, `avg_fill_price`, and detailed commission breakdowns (`total_commission_usd`, `fee_breakdown`).\n\n2.  **Sophisticated Processing Logic:**\n    *   A new private method, `_process_individual_fills`, was implemented to parse the `fills` array from the Binance API response, populating the `individual_fills` list.\n    *   The `_process_order_response` method was enhanced to orchestrate the fill processing, calculate aggregate statistics, and handle various order statuses.\n    *   Logic now explicitly distinguishes between partial, complete, and potential over-fills using helper methods (`is_partial_fill`, `is_complete_fill`).\n\n3.  **Execution Quality Metrics:**\n    *   Slippage calculation was implemented for both MARKET and LIMIT orders, comparing the average fill price against the market price at execution or the limit price.\n    *   Additional metrics such as `price_impact_percentage` and a custom `execution_efficiency_score` (0-100) have been added to provide a quantitative measure of execution quality.\n\n4.  **Enriched Event Publishing:**\n    *   The `ORDER_FILLED` event published via the `EventHub` now contains the fully populated `ExecutionResult` object. This provides downstream consumers with a rich dataset including all individual fill details, commission costs in USD, and calculated quality metrics, enabling advanced portfolio tracking and performance analysis.\n</info added on 2025-09-24T09:15:32.841Z>\n</info added on 2025-09-23T22:07:07.115Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "오류 처리 및 재시도 메커니즘 구현",
            "description": "주문 실행 과정에서 발생할 수 있는 오류를 처리하고 재시도하는 메커니즘을 구현합니다.",
            "dependencies": [
              "7.2"
            ],
            "details": "네트워크 오류, API 제한, 잔액 부족 등의 다양한 오류 상황을 처리하고, 재시도 가능한 오류에 대해서는 지수 백오프 방식으로 재시도하는 로직을 구현합니다. 오류 로그 기록과 알림 기능을 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "ORDER_FILLED 이벤트 발행 기능 구현",
            "description": "주문 체결 완료 시 ORDER_FILLED 이벤트를 EventHub에 발행하는 기능을 구현합니다.",
            "dependencies": [
              "7.4"
            ],
            "details": "주문이 성공적으로 체결되었을 때 체결 정보를 포함한 ORDER_FILLED 이벤트를 생성하고 EventHub를 통해 다른 모듈들에게 알리는 기능을 구현합니다. 이벤트 데이터에는 체결가격, 수량, 시간, 수수료 등이 포함됩니다.\n<info added on 2025-09-24T10:52:40.830Z>\n**구현 완료 상세 내역:**\n\n해당 기능은 `trading_bot/execution/execution_engine.py` 파일의 `_handle_order_status_update` 메소드 내에 핵심 로직이 구현되었습니다. (대략 2040-2150 라인)\n\n기본 요구사항을 초과하여, `FILLED` 및 `PARTIALLY_FILLED` 주문 상태 모두에 대해 `ORDER_FILLED` 이벤트를 발행하도록 구현되었습니다. 발행되는 이벤트 데이터는 다음과 같은 매우 상세한 정보를 포함합니다:\n\n*   **포괄적인 데이터 구조:** 전체 주문 상세 정보가 담긴 `ExecutionResult` 객체, 개별 체결 내역(fills) 배열, 체결 상태 플래그(`is_partial_fill`, `is_complete_fill` 등)를 포함합니다.\n*   **상세 수수료 정보:** 수수료 금액(`commission_amount`), 자산(`commission_asset`), USD 환산 총액(`total_commission_usd`) 및 상세 내역(`fee_breakdown`)을 제공합니다.\n*   **고급 실행 품질 지표:** 슬리피지(`slippage_percentage`), 가격 영향(`price_impact_percentage`), 실행 효율성 점수(`execution_efficiency_score`), 실행 지연 시간(`execution_latency_ms`) 등 고급 분석 메트릭을 계산하여 포함합니다.\n*   **거래 가치 계산:** 총 거래 가치(`total_trade_value`) 및 순 거래 가치(`net_trade_value`)를 계산합니다.\n*   **원시 데이터:** 완전한 투명성과 디버깅을 위해 Binance API로부터 받은 원본 응답 데이터를 포함합니다.\n</info added on 2025-09-24T10:52:40.830Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Portfolio Manager",
        "description": "Create a module to track the current portfolio state, including open positions, account balance, and unrealized PnL.",
        "details": "In `trading/portfolio_manager.py`, create a class that subscribes to `ORDER_FILLED` events. It will maintain a dictionary or list of `Position` objects. It should update positions on new fills (opening, closing, or partial fills) and periodically update the account balance and unrealized PnL by querying the `BinanceClient`.",
        "testStrategy": "Write unit tests to simulate a sequence of `ORDER_FILLED` events (buy to open, sell to close) and verify that the internal state of the `PortfolioManager` (open positions, PnL) is updated correctly.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "포지션 상태 추적 시스템 구현",
            "description": "Position 클래스와 포지션 상태를 관리하는 핵심 데이터 구조를 구현합니다.",
            "dependencies": [],
            "details": "trading/portfolio_manager.py에 Position 클래스를 정의하고, 포지션의 진입가격, 수량, 방향(long/short), 미실현 손익 등을 추적할 수 있는 속성들을 구현합니다. PortfolioManager 클래스에서 포지션들을 딕셔너리나 리스트로 관리하는 구조를 설계합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "ORDER_FILLED 이벤트 처리 로직 구현",
            "description": "EventHub의 ORDER_FILLED 이벤트를 구독하고 포지션 변경을 처리하는 로직을 구현합니다.",
            "dependencies": [
              "8.1"
            ],
            "details": "PortfolioManager가 ORDER_FILLED 이벤트를 구독하도록 설정하고, 새로운 주문 체결 시 포지션을 열거나, 기존 포지션을 부분적으로 또는 완전히 닫는 로직을 구현합니다. 포지션의 평균 진입가격 계산과 수량 업데이트를 처리합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "계좌 잔고 업데이트 시스템 구현",
            "description": "BinanceClient를 사용하여 계좌 잔고를 주기적으로 조회하고 업데이트하는 시스템을 구현합니다.",
            "dependencies": [
              "8.1"
            ],
            "details": "PortfolioManager에서 BinanceClient의 계좌 정보 조회 API를 호출하여 현재 잔고를 가져오는 메서드를 구현합니다. 주기적으로 잔고를 동기화하는 스케줄링 로직을 추가하고, 잔고 변경 시 적절한 이벤트를 발행합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "미실현 손익(PnL) 계산 로직 구현",
            "description": "현재 포지션들의 미실현 손익을 계산하고 업데이트하는 로직을 구현합니다.",
            "dependencies": [
              "8.1",
              "8.3"
            ],
            "details": "각 포지션별로 현재 시장가격과 진입가격을 비교하여 미실현 손익을 계산하는 메서드를 구현합니다. 전체 포트폴리오의 총 미실현 손익을 집계하고, 실시간으로 업데이트되도록 시장 데이터와 연동합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "포트폴리오 상태 조회 및 리포팅 기능 구현",
            "description": "포트폴리오의 현재 상태를 조회하고 리포트를 생성하는 기능을 구현합니다.",
            "dependencies": [
              "8.2",
              "8.4"
            ],
            "details": "PortfolioManager에서 현재 열린 포지션 목록, 총 잔고, 총 미실현 손익 등을 조회할 수 있는 메서드들을 구현합니다. 포트폴리오 상태 변경 시 적절한 이벤트를 발행하여 다른 모듈들이 상태를 알 수 있도록 합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Integrate Discord Notification System",
        "description": "Set up a notification service to send real-time alerts for critical events like trade execution, errors, and system status changes to a Discord channel.",
        "details": "Create `notification/discord_notifier.py`. This class will subscribe to relevant events from the `EventHub`, such as `ORDER_FILLED`, `SYSTEM_ERROR`, and `CONNECTION_STATUS_CHANGED`. Upon receiving an event, it will format a structured message and send it to the Discord webhook URL specified in the configuration file.",
        "testStrategy": "Create a dedicated test Discord channel. Write an integration test that manually publishes various events and verifies that correctly formatted messages appear in the channel. Test edge cases like an invalid webhook URL.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Discord 웹훅 클라이언트 설정 구현",
            "description": "Discord 웹훅 URL을 사용하여 메시지를 전송할 수 있는 기본 클라이언트 클래스를 구현합니다.",
            "dependencies": [],
            "details": "notification/discord_notifier.py에서 Discord 웹훅 클라이언트를 설정합니다. 설정 파일에서 웹훅 URL을 읽어오고, HTTP 요청을 통해 Discord API에 메시지를 전송하는 기본 기능을 구현합니다. 연결 테스트 및 기본 오류 처리를 포함합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "이벤트별 메시지 포맷팅 시스템 구현",
            "description": "다양한 이벤트 타입에 대해 구조화된 Discord 메시지 포맷을 생성하는 시스템을 구현합니다.",
            "dependencies": [],
            "details": "ORDER_FILLED, SYSTEM_ERROR, CONNECTION_STATUS_CHANGED 등 각 이벤트 타입별로 적절한 메시지 포맷을 정의합니다. 이벤트 데이터를 받아서 읽기 쉬운 Discord 메시지로 변환하는 포맷터 함수들을 구현합니다. 색상 코딩, 임베드 메시지 등 Discord의 풍부한 메시지 기능을 활용합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "EventHub 이벤트 구독 및 처리 로직 구현",
            "description": "EventHub에서 관련 이벤트들을 구독하고 처리하는 로직을 구현합니다.",
            "dependencies": [
              "9.2"
            ],
            "details": "DiscordNotifier 클래스가 EventHub에서 ORDER_FILLED, SYSTEM_ERROR, CONNECTION_STATUS_CHANGED 이벤트를 구독하도록 설정합니다. 각 이벤트를 받았을 때 적절한 메시지 포맷터를 호출하고 Discord로 전송하는 이벤트 핸들러를 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "웹훅 전송 및 오류 처리 구현",
            "description": "Discord 웹훅으로 메시지를 안전하게 전송하고 다양한 오류 상황을 처리하는 로직을 구현합니다.",
            "dependencies": [
              "9.1",
              "9.3"
            ],
            "details": "포맷된 메시지를 Discord 웹훅으로 전송하는 기능을 구현합니다. 네트워크 오류, 잘못된 웹훅 URL, 속도 제한 등의 오류 상황을 처리합니다. 재시도 로직, 로깅, 그리고 실패한 알림에 대한 백업 처리 방법을 포함합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Create Main Application Entrypoint and Integration",
        "description": "Develop the main script to initialize, configure, and run all the components of the trading bot, tying everything together into a functional application.",
        "details": "Create a `main.py` file in the root of the `trading_bot` directory. This script will: 1. Initialize the `ConfigManager`, `EventHub`, and `Logger`. 2. Instantiate all other modules (`BinanceClient`, `DataProcessor`, `ICTStrategy`, `RiskManager`, `ExecutionEngine`, `PortfolioManager`, `DiscordNotifier`). 3. Register all subscribers to their respective events in the `EventHub`. 4. Start the main asynchronous event loop, beginning with the `WebSocketManager` connection.",
        "testStrategy": "This is the final integration test. Run the `main.py` script connected to the Binance Testnet. Monitor the logs and Discord channel. Manually create market conditions that should trigger a trade and verify the entire pipeline works: data received -> signal generated -> risk applied -> order executed -> position tracked -> notification sent.",
        "priority": "high",
        "dependencies": [
          8,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "코어 컴포넌트 초기화 시퀀스 구현",
            "description": "ConfigManager, EventHub, Logger를 올바른 순서로 초기화하고 기본 설정을 로드하는 로직을 구현합니다.",
            "dependencies": [],
            "details": "main.py에서 시스템의 핵심 컴포넌트들을 안전한 순서로 초기화합니다. ConfigManager를 먼저 초기화하여 설정을 로드하고, EventHub를 생성한 후 Logger를 설정합니다. 각 초기화 단계에서 발생할 수 있는 예외를 처리하고 적절한 로깅을 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "모든 트레이딩 모듈 인스턴스화",
            "description": "BinanceClient, DataProcessor, ICTStrategy, RiskManager, ExecutionEngine, PortfolioManager, DiscordNotifier를 생성하고 의존성을 주입합니다.",
            "dependencies": [
              "10.1"
            ],
            "details": "초기화된 코어 컴포넌트들을 사용하여 모든 트레이딩 관련 모듈들을 인스턴스화합니다. 각 모듈에 필요한 의존성(EventHub, ConfigManager 등)을 올바르게 주입하고, 모듈 간의 참조 관계를 설정합니다. 모듈 생성 실패 시 적절한 에러 처리를 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "EventHub 이벤트 구독 연결 설정",
            "description": "모든 모듈들을 EventHub의 해당 이벤트에 구독자로 등록하고 이벤트 플로우를 설정합니다.",
            "dependencies": [
              "10.2"
            ],
            "details": "DataProcessor, ICTStrategy, RiskManager, ExecutionEngine, PortfolioManager, DiscordNotifier를 EventHub의 적절한 이벤트 토픽에 구독자로 등록합니다. 이벤트 플로우가 올바르게 연결되도록 구독 순서를 관리하고, 구독 등록 실패 시 에러 처리를 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "비동기 메인 루프 및 WebSocket 연결 시작",
            "description": "메인 비동기 이벤트 루프를 시작하고 WebSocketManager를 통해 실시간 데이터 스트림을 개시합니다.",
            "dependencies": [
              "10.3"
            ],
            "details": "asyncio를 사용하여 메인 이벤트 루프를 설정하고, WebSocketManager의 연결을 시작합니다. 시스템이 안정적으로 실행되도록 태스크 스케줄링을 관리하고, 비동기 작업들의 생명주기를 제어합니다. 연결 실패나 예외 발생 시 적절한 복구 로직을 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "시스템 시작/종료 로직 및 통합 검증",
            "description": "graceful shutdown 로직을 구현하고 전체 시스템의 통합 테스트를 수행합니다.",
            "dependencies": [
              "10.4"
            ],
            "details": "SIGINT, SIGTERM 신호 처리를 통한 graceful shutdown을 구현합니다. 시스템 종료 시 모든 연결을 안전하게 닫고 리소스를 정리합니다. Binance Testnet을 사용하여 전체 파이프라인이 정상 작동하는지 검증하고, 로그 및 Discord 알림이 올바르게 작동하는지 확인합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Trading Bot Paper Trading and Performance Validation",
        "description": "Run the fully integrated trading bot in paper trading mode on the mainnet to validate system stability, analyze signal quality, and measure overall strategy performance across diverse market conditions.",
        "details": "This task involves setting up a long-running paper trading session and creating tools to analyze the results. 1. **Configuration Setup**: Create a new configuration file, `config/paper_mainnet.yml`, that sets `paper_trading: true` in the `ExecutionEngine` and uses mainnet API endpoints. This ensures no real funds are at risk. 2. **Performance Logging Module**: Create a new module `analysis/performance_logger.py`. The `PerformanceLogger` class will subscribe to `ORDER_FILLED` events from the `EventHub`. For each closed trade, it will log a structured record to a CSV file (`trades.csv`) containing: `timestamp`, `symbol`, `direction`, `entry_price`, `exit_price`, `size`, `pnl`, `entry_reason`, `exit_reason`. 3. **Portfolio Snapshot Logging**: Enhance the `PortfolioManager` in `trading/portfolio_manager.py` to publish a `PORTFOLIO_SNAPSHOT` event every hour. The `PerformanceLogger` will also subscribe to this event and log the `timestamp`, `total_balance`, `unrealized_pnl`, and `open_positions_count` to a separate file (`portfolio_history.csv`). 4. **Stability Monitoring**: In `main.py`, implement a 'heartbeat' mechanism that publishes a `SYSTEM_HEARTBEAT` event every hour. The `DiscordNotifier` will subscribe to this and send a 'System OK' message to Discord, confirming the bot is running. Also, ensure the `WebSocketManager`'s reconnection logic publishes a `WEBSOCKET_RECONNECTED` event, which the `DiscordNotifier` will report. 5. **Analysis Script**: Create a Jupyter Notebook or Python script `analysis/analyzer.ipynb`. This script will use pandas, matplotlib, and quantstats to load data from `trades.csv` and `portfolio_history.csv`. It will generate a performance report including: an equity curve, max drawdown, Sharpe ratio, win/loss ratio, profit factor, and trade distribution analysis.",
        "testStrategy": "1. **Deployment**: Run the bot using `python trading_bot/main.py --config config/paper_mainnet.yml` on a stable server (e.g., a cloud VM) for an extended period (e.g., 1-2 weeks) to capture data from various market phases. 2. **Real-time Monitoring**: Actively monitor the dedicated Discord channel for trade notifications, error alerts, and hourly heartbeat messages to ensure system uptime and responsiveness. 3. **Data Verification**: Periodically check that the `trades.csv` and `portfolio_history.csv` files are being populated correctly with new data. 4. **Post-Mortem Analysis**: After the testing period concludes, execute the `analysis/analyzer.ipynb` notebook. Review the generated performance report and visualizations. 5. **Strategy Evaluation**: Analyze the results to identify strengths and weaknesses. For example, check if the strategy underperforms in specific volatility regimes or times of day. The outcome of this test will be a data-driven decision on whether to refine the strategy, fix stability issues, or proceed towards live deployment.",
        "status": "pending",
        "dependencies": [
          10
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Paper Trading Configuration and Simulate Fills in Execution Engine",
            "description": "Create a new configuration file for mainnet paper trading and modify the Execution Engine to simulate order fills when paper trading is enabled, ensuring no real funds are used.",
            "dependencies": [],
            "details": "Create a new file `config/paper_mainnet.yml`. This file should inherit from the default configuration but override settings for the `ExecutionEngine` to set `paper_trading: true` and use mainnet API endpoints. Then, modify `trading_bot/execution/execution_engine.py`. In the `execute_order` method, add a conditional check for the `paper_trading` flag. If true, the engine should bypass the actual API call to the exchange, simulate a successful order fill (e.g., at the current market price), and publish the corresponding `ORDER_FILLED` event to the EventHub, mimicking the behavior of a live trade.",
            "status": "pending",
            "testStrategy": "Run the bot with the new `--config config/paper_mainnet.yml`. Place a test order manually or via a strategy signal. Verify that no order appears on the exchange. Check the application logs and EventHub (if monitored) to confirm that an `ORDER_FILLED` event was published with simulated fill data."
          },
          {
            "id": 2,
            "title": "Implement System Stability Monitoring and Alerts",
            "description": "Enhance system monitoring by implementing a heartbeat mechanism and WebSocket reconnection alerts, with notifications sent to Discord to confirm the bot's operational status during long-running sessions.",
            "dependencies": [],
            "details": "In `trading_bot/main.py`, implement a background async task that publishes a `SYSTEM_HEARTBEAT` event to the `EventHub` every hour. In `trading_bot/market_data/websocket_manager.py`, locate the reconnection logic and ensure it publishes a `WEBSOCKET_RECONNECTED` event upon successfully re-establishing a connection. Update `trading_bot/notification/discord_notifier.py` to subscribe to both `SYSTEM_HEARTBEAT` and `WEBSOCKET_RECONNECTED` events and send appropriately formatted status messages to the configured Discord channel.",
            "status": "pending",
            "testStrategy": "Run the bot. Verify that a 'System OK' message appears in Discord after one hour. Manually disconnect and reconnect the network to trigger the WebSocket reconnection logic and verify that a 'WebSocket Reconnected' alert is sent to Discord."
          },
          {
            "id": 3,
            "title": "Create Performance Logger for Trade Execution",
            "description": "Create a new `PerformanceLogger` module that subscribes to filled order events and logs the details of each completed trade to a `trades.csv` file for later analysis.",
            "dependencies": [
              "11.1"
            ],
            "details": "Create a new file `trading_bot/analysis/performance_logger.py`. Inside, define a `PerformanceLogger` class. This class will subscribe to the `ORDER_FILLED` event on the `EventHub`. Upon receiving an event, it will process the payload to extract and structure data for a closed trade, including `timestamp`, `symbol`, `direction`, `entry_price`, `exit_price`, `size`, `pnl`, `entry_reason`, and `exit_reason`. This structured record will be appended as a new row to a CSV file named `trades.csv`. Instantiate this logger in `trading_bot/main.py` so it runs as part of the main application.",
            "status": "pending",
            "testStrategy": "With the paper trading mode active, trigger a few trades. After the session, inspect the generated `trades.csv` file. Verify that it contains the correct headers and that each row accurately reflects the data from the `ORDER_FILLED` events."
          },
          {
            "id": 4,
            "title": "Add Hourly Portfolio Snapshot Logging",
            "description": "Enhance the `PortfolioManager` to publish hourly portfolio snapshots and update the `PerformanceLogger` to subscribe to and log this data to a separate `portfolio_history.csv` file.",
            "dependencies": [
              "11.3"
            ],
            "details": "Modify `trading_bot/trading/portfolio_manager.py`. Add a new background task that runs on an hourly timer. In each iteration, this task will gather the current portfolio state (`total_balance`, `unrealized_pnl`, `open_positions_count`) and publish it to the `EventHub` under a new `PORTFOLIO_SNAPSHOT` event topic. Then, enhance the `PerformanceLogger` in `trading_bot/analysis/performance_logger.py` to also subscribe to this new `PORTFOLIO_SNAPSHOT` event. When the event is received, the logger will write the `timestamp`, `total_balance`, `unrealized_pnl`, and `open_positions_count` to a new file, `portfolio_history.csv`.",
            "status": "pending",
            "testStrategy": "Run the bot for over an hour. Check for the creation of `portfolio_history.csv`. Verify that the file contains at least one entry with the correct headers and data reflecting the portfolio's state at that time."
          },
          {
            "id": 5,
            "title": "Develop Performance Analysis Script",
            "description": "Create a Jupyter Notebook or Python script to load and analyze the data from `trades.csv` and `portfolio_history.csv`, generating a comprehensive performance report with metrics and visualizations.",
            "dependencies": [
              "11.3",
              "11.4"
            ],
            "details": "Create a new analysis script, `analysis/analyzer.ipynb`. This notebook will use the pandas library to load the `trades.csv` and `portfolio_history.csv` files into DataFrames. It will then leverage analysis libraries such as `matplotlib`, `seaborn`, and `quantstats` to process the data. The script must generate and display an equity curve, max drawdown, Sharpe ratio, win/loss ratio, profit factor, and various charts for trade distribution analysis (e.g., PnL by symbol, trades per day).",
            "status": "pending",
            "testStrategy": "Populate `trades.csv` and `portfolio_history.csv` with sample data covering wins, losses, and open positions. Run the `analysis/analyzer.ipynb` script. Verify that all calculations are correct and that all specified charts and metrics are generated without errors."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-21T14:07:37.892Z",
      "updated": "2025-09-26T18:39:19.950Z",
      "description": "Tasks for master context"
    }
  }
}