"""
Abstract base strategy module for trading signal generation.

This module provides the foundational abstract base class for all trading
strategies, following SOLID principles and establishing a consistent interface
for strategy implementations across the trading bot system.
"""

import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional

from trading_bot.core.event_hub import EventHub, EventType
from trading_bot.core.logger import get_module_logger
from trading_bot.market_data.data_processor import MarketData


class StrategyError(Exception):
    """Base exception for strategy-related errors."""


class InvalidStrategyConfigError(StrategyError):
    """Exception raised for invalid strategy configuration."""


class SignalGenerationError(StrategyError):
    """Exception raised for signal generation errors."""


class StrategyInitializationError(StrategyError):
    """Exception raised for strategy initialization errors."""


class SignalType(Enum):
    """Trading signal types for strategy output."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    STRONG_BUY = "strong_buy"
    STRONG_SELL = "strong_sell"


class SignalStrength(Enum):
    """Signal strength levels for confidence indication."""

    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"
    VERY_STRONG = "very_strong"


@dataclass
class TradingSignal:
    """Trading signal data structure for strategy output.

    This dataclass provides a standardized format for trading signals
    generated by strategy implementations.
    """

    symbol: str
    signal_type: SignalType
    strength: SignalStrength
    price: float
    timestamp: int
    strategy_name: str
    confidence: float
    metadata: Dict[str, Any] = field(default_factory=dict)
    reasoning: str = ""
    target_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None

    def __post_init__(self) -> None:
        """Validate signal data after initialization."""
        if not self.symbol:
            raise InvalidStrategyConfigError("Symbol cannot be empty")
        if self.price <= 0:
            raise InvalidStrategyConfigError("Price must be positive")
        if not 0.0 <= self.confidence <= 1.0:
            raise InvalidStrategyConfigError("Confidence must be between 0.0 and 1.0")
        if self.target_price is not None and self.target_price <= 0:
            raise InvalidStrategyConfigError("Target price must be positive")
        if self.stop_loss is not None and self.stop_loss <= 0:
            raise InvalidStrategyConfigError("Stop loss must be positive")
        if self.take_profit is not None and self.take_profit <= 0:
            raise InvalidStrategyConfigError("Take profit must be positive")


@dataclass
class StrategyConfiguration:
    """Strategy configuration data structure.

    This dataclass defines the configuration parameters that all strategies
    must support for consistent initialization and operation.
    """

    name: str
    symbol: str
    timeframe: str
    enabled: bool = True
    risk_tolerance: float = 0.02
    min_confidence: float = 0.6
    max_position_size: float = 1.0
    use_stop_loss: bool = True
    use_take_profit: bool = True
    parameters: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate configuration data after initialization."""
        if not self.name:
            raise InvalidStrategyConfigError("Strategy name cannot be empty")
        if not self.symbol:
            raise InvalidStrategyConfigError("Symbol cannot be empty")
        if not self.timeframe:
            raise InvalidStrategyConfigError("Timeframe cannot be empty")
        if not 0.0 <= self.risk_tolerance <= 1.0:
            raise InvalidStrategyConfigError(
                "Risk tolerance must be between 0.0 and 1.0"
            )
        if not 0.0 <= self.min_confidence <= 1.0:
            raise InvalidStrategyConfigError(
                "Min confidence must be between 0.0 and 1.0"
            )
        if self.max_position_size <= 0:
            raise InvalidStrategyConfigError("Max position size must be positive")


class IStrategyInterface(ABC):
    """Abstract interface for trading strategy implementations.

    This interface defines the contract for trading strategy implementations,
    following the Interface Segregation Principle and ensuring consistent
    behavior across all strategy types.
    """

    @abstractmethod
    def generate_signal(self, market_data: MarketData) -> Optional[TradingSignal]:
        """Generate trading signal based on market data.

        Args:
            market_data: Current market data for analysis

        Returns:
            TradingSignal if conditions are met, None otherwise

        Raises:
            SignalGenerationError: If signal generation fails
        """

    @abstractmethod
    def initialize(self) -> None:
        """Initialize strategy with configuration and dependencies.

        Raises:
            StrategyInitializationError: If initialization fails
        """

    @abstractmethod
    def cleanup(self) -> None:
        """Clean up strategy resources and subscriptions."""

    @abstractmethod
    def get_strategy_info(self) -> Dict[str, Any]:
        """Get strategy information and current state.

        Returns:
            Dictionary containing strategy metadata and state
        """


class BaseStrategy(IStrategyInterface):
    """Abstract base class for all trading strategy implementations.

    This class provides the foundational structure and common functionality
    for all trading strategies, following SOLID principles and ensuring
    consistent behavior across different strategy implementations.

    The class adheres to the Single Responsibility Principle by focusing
    solely on strategy management and signal generation coordination.

    Attributes:
        _config: Strategy configuration instance
        _event_hub: Event hub for subscribing/publishing events
        _logger: Logger instance for strategy-specific logging
        _is_initialized: Flag indicating initialization status
        _signals_generated: Counter for generated signals
        _last_signal_time: Timestamp of last signal generation
    """

    def __init__(
        self,
        config: StrategyConfiguration,
        event_hub: EventHub,
    ) -> None:
        """Initialize base strategy with configuration and dependencies.

        Args:
            config: Strategy configuration instance
            event_hub: Event hub for event communication

        Raises:
            InvalidStrategyConfigError: If configuration is invalid
            StrategyInitializationError: If initialization fails
        """
        if not isinstance(config, StrategyConfiguration):
            raise InvalidStrategyConfigError(
                "Config must be StrategyConfiguration instance"
            )

        if not isinstance(event_hub, EventHub):
            raise StrategyInitializationError("Event hub must be EventHub instance")

        self._config = config
        self._event_hub = event_hub
        self._logger = get_module_logger(f"strategy_{config.name.lower()}")

        # Strategy state
        self._is_initialized = False
        self._signals_generated = 0
        self._last_signal_time = 0
        self._last_market_data: Optional[MarketData] = None

        # Performance tracking
        self._signal_history: List[TradingSignal] = []
        self._error_count = 0
        self._start_time = int(time.time())

        self._logger.info(f"Initialized base strategy: {config.name}")

    def generate_signal(self, market_data: MarketData) -> Optional[TradingSignal]:
        """Generate trading signal based on market data.

        This method implements the Template Method pattern, providing
        common validation and processing while delegating the actual
        signal generation logic to concrete implementations.

        Args:
            market_data: Current market data for analysis

        Returns:
            TradingSignal if conditions are met, None otherwise

        Raises:
            SignalGenerationError: If signal generation fails
        """
        if not self._is_initialized:
            raise SignalGenerationError("Strategy not initialized")

        if not self._is_strategy_enabled():
            return None

        try:
            # Validate market data
            if not self._validate_market_data(market_data):
                self._logger.warning(f"Invalid market data for {market_data.symbol}")
                return None

            # Check if we should process this data
            if not self._should_process_data(market_data):
                return None

            # Store current market data
            self._last_market_data = market_data

            # Generate signal using concrete implementation
            signal = self._generate_signal_implementation(market_data)

            # Validate and process generated signal
            if signal:
                self._validate_signal(signal)
                self._post_process_signal(signal)
                self._publish_signal(signal)

                # Update statistics
                self._signals_generated += 1
                self._last_signal_time = int(time.time())
                self._signal_history.append(signal)

                self._logger.info(
                    f"Generated {signal.signal_type.value} signal for "
                    f"{signal.symbol} at {signal.price} with confidence "
                    f"{signal.confidence:.3f}"
                )

            return signal

        except Exception as e:
            self._error_count += 1
            self._logger.error(f"Error generating signal: {e}")
            raise SignalGenerationError(f"Failed to generate signal: {e}")

    @abstractmethod
    def _generate_signal_implementation(
        self, market_data: MarketData
    ) -> Optional[TradingSignal]:
        """Concrete signal generation implementation.

        This method must be implemented by concrete strategy classes
        to provide the actual signal generation logic.

        Args:
            market_data: Current market data for analysis

        Returns:
            TradingSignal if conditions are met, None otherwise
        """

    def initialize(self) -> None:
        """Initialize strategy with configuration and dependencies.

        Raises:
            StrategyInitializationError: If initialization fails
        """
        try:
            self._logger.info(f"Initializing strategy: {self._config.name}")

            # Validate configuration
            self._validate_configuration()

            # Subscribe to market data events for the configured symbol
            self._subscribe_to_events()

            # Perform strategy-specific initialization
            self._initialize_strategy()

            # Mark as initialized
            self._is_initialized = True

            self._logger.info(f"Strategy initialized successfully: {self._config.name}")

        except Exception as e:
            self._logger.error(f"Failed to initialize strategy: {e}")
            raise StrategyInitializationError(f"Initialization failed: {e}")

    def cleanup(self) -> None:
        """Clean up strategy resources and subscriptions."""
        try:
            self._logger.info(f"Cleaning up strategy: {self._config.name}")

            # Unsubscribe from events
            self._unsubscribe_from_events()

            # Perform strategy-specific cleanup
            self._cleanup_strategy()

            # Reset state
            self._is_initialized = False

            # Log final statistics
            self._log_final_statistics()

            self._logger.info(f"Strategy cleanup completed: {self._config.name}")

        except Exception as e:
            self._logger.error(f"Error during strategy cleanup: {e}")

    def get_strategy_info(self) -> Dict[str, Any]:
        """Get strategy information and current state.

        Returns:
            Dictionary containing strategy metadata and state
        """
        return {
            "name": self._config.name,
            "symbol": self._config.symbol,
            "timeframe": self._config.timeframe,
            "enabled": self._config.enabled,
            "initialized": self._is_initialized,
            "signals_generated": self._signals_generated,
            "last_signal_time": self._last_signal_time,
            "error_count": self._error_count,
            "start_time": self._start_time,
            "uptime_seconds": int(time.time()) - self._start_time,
            "configuration": self._config,
            "performance_metrics": self._get_performance_metrics(),
        }

    def _validate_market_data(self, market_data: MarketData) -> bool:
        """Validate market data for processing.

        Args:
            market_data: Market data to validate

        Returns:
            True if data is valid, False otherwise
        """
        try:
            # Check symbol match
            if market_data.symbol.upper() != self._config.symbol.upper():
                return False

            # Check data age
            current_time = int(time.time() * 1000)
            max_age_ms = 60000  # 60 seconds
            if current_time - market_data.timestamp > max_age_ms:
                return False

            # Check price validity
            if market_data.price <= 0:
                return False

            return True

        except Exception as e:
            self._logger.error(f"Error validating market data: {e}")
            return False

    def _should_process_data(self, market_data: MarketData) -> bool:
        """Determine if market data should be processed.

        Args:
            market_data: Market data to check

        Returns:
            True if data should be processed, False otherwise
        """
        # This can be overridden by concrete implementations
        return True

    def _validate_signal(self, signal: TradingSignal) -> None:
        """Validate generated signal.

        Args:
            signal: Trading signal to validate

        Raises:
            SignalGenerationError: If signal is invalid
        """
        if signal.confidence < self._config.min_confidence:
            raise SignalGenerationError(
                f"Signal confidence {signal.confidence} below minimum "
                f"{self._config.min_confidence}"
            )

    def _post_process_signal(self, signal: TradingSignal) -> None:
        """Post-process generated signal.

        Args:
            signal: Trading signal to post-process
        """
        # Add strategy metadata
        signal.metadata.update(
            {
                "strategy_config": self._config.name,
                "generation_time": int(time.time()),
                "market_data_timestamp": signal.timestamp,
            }
        )

    def _publish_signal(self, signal: TradingSignal) -> None:
        """Publish trading signal to event hub.

        Args:
            signal: Trading signal to publish
        """
        try:
            event_data = {
                "signal": signal,
                "strategy_name": self._config.name,
                "symbol": signal.symbol,
                "timestamp": signal.timestamp,
            }

            # Publish generic signal event
            self._event_hub.publish(EventType.TRADING_SIGNAL_GENERATED, event_data)

            # Publish specific signal type event
            signal_event_map = {
                SignalType.BUY: EventType.BUY_SIGNAL,
                SignalType.SELL: EventType.SELL_SIGNAL,
                SignalType.HOLD: EventType.HOLD_SIGNAL,
                SignalType.STRONG_BUY: EventType.BUY_SIGNAL,
                SignalType.STRONG_SELL: EventType.SELL_SIGNAL,
            }

            specific_event = signal_event_map.get(signal.signal_type)
            if specific_event:
                self._event_hub.publish(specific_event, event_data)

        except Exception as e:
            self._logger.error(f"Error publishing signal: {e}")

    def _is_strategy_enabled(self) -> bool:
        """Check if strategy is enabled for signal generation.

        Returns:
            True if strategy is enabled, False otherwise
        """
        return self._config.enabled and self._is_initialized

    def _validate_configuration(self) -> None:
        """Validate strategy configuration.

        Raises:
            InvalidStrategyConfigError: If configuration is invalid
        """
        # Base validation is handled by StrategyConfiguration.__post_init__
        # Concrete implementations can override for additional validation

    def _subscribe_to_events(self) -> None:
        """Subscribe to required events."""
        # This can be overridden by concrete implementations
        # Default implementation doesn't subscribe to additional events

    def _unsubscribe_from_events(self) -> None:
        """Unsubscribe from events."""
        # This can be overridden by concrete implementations

    @abstractmethod
    def _initialize_strategy(self) -> None:
        """Perform strategy-specific initialization.

        This method must be implemented by concrete strategy classes
        to handle any strategy-specific initialization logic.
        """

    @abstractmethod
    def _cleanup_strategy(self) -> None:
        """Perform strategy-specific cleanup.

        This method must be implemented by concrete strategy classes
        to handle any strategy-specific cleanup logic.
        """

    def _get_performance_metrics(self) -> Dict[str, Any]:
        """Get strategy performance metrics.

        Returns:
            Dictionary containing performance metrics
        """
        if not self._signal_history:
            return {
                "total_signals": 0,
                "signal_types": {},
                "average_confidence": 0.0,
                "error_rate": self._error_count / max(1, self._signals_generated),
            }

        signal_types = {}
        total_confidence = 0.0

        for signal in self._signal_history:
            signal_type = signal.signal_type.value
            signal_types[signal_type] = signal_types.get(signal_type, 0) + 1
            total_confidence += signal.confidence

        return {
            "total_signals": len(self._signal_history),
            "signal_types": signal_types,
            "average_confidence": total_confidence / len(self._signal_history),
            "error_rate": self._error_count / max(1, self._signals_generated),
        }

    def _log_final_statistics(self) -> None:
        """Log final strategy statistics."""
        stats = self.get_strategy_info()
        self._logger.info(f"Final strategy statistics: {stats}")


def create_strategy_configuration(
    name: str, symbol: str, timeframe: str, **kwargs: Any
) -> StrategyConfiguration:
    """Factory function to create StrategyConfiguration instance.

    Args:
        name: Strategy name
        symbol: Trading symbol
        timeframe: Timeframe for strategy operation
        **kwargs: Additional configuration parameters

    Returns:
        StrategyConfiguration: Configured strategy configuration instance

    Raises:
        InvalidStrategyConfigError: If configuration parameters are invalid
    """
    return StrategyConfiguration(
        name=name,
        symbol=symbol,
        timeframe=timeframe,
        enabled=kwargs.get("enabled", True),
        risk_tolerance=kwargs.get("risk_tolerance", 0.02),
        min_confidence=kwargs.get("min_confidence", 0.6),
        max_position_size=kwargs.get("max_position_size", 1.0),
        use_stop_loss=kwargs.get("use_stop_loss", True),
        use_take_profit=kwargs.get("use_take_profit", True),
        parameters=kwargs.get("parameters", {}),
        metadata=kwargs.get("metadata", {}),
    )
